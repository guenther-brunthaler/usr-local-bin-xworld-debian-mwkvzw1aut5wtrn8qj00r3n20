#! /bin/sh
exit_version() {
	cat << EOF; exit
$APPLICATION_NAME Version 2017.192.3

Copyright (c) 2017 Guenther Brunthaler. All rights reserved.

This script file is free software.
Distribution is permitted under the terms of the GPLv3.
EOF
}
APPLICATION_NAME=${0##*/}

set -e
trap 'test $? = 0 || echo "$0 failed!" >& 2' 0

exit_help() {
	cat << EOF; echo; exit_version # Line width: 66
$APPLICATION_NAME - show download sizes for APT packages

Usage: $APPLICATION_NAME [ <options> ] [<pkg_grp1> <pkg_grp2> ...]

where <pkg_grp1> ... are groups consisting of either a single
installation package name or multiple package names (as one
argument per group, the names within the argument separated by
spaces).

$APPLICATION_NAME will then calculate the combined download size
for every group and display the result in multiple lines, one
line per group. The lines will be sorted by group size.

Each group, whether containing just a single package or multiple
packages, must be specified as an individual argument to
$APPLICATION_NAME. This means that groups containing more than
one package must be enclosed within quotation marks.

Alternatively, the groups can also be read from a file rather
than taken from the program's arguments.

This mode is automatically enabled when no arguments have been
specified; $APPLICATION_NAME reads then a list of package groups
from standard input, one group per line. Within each line, the
packages within a group must be separated by a space. In this
case, no enclosing in quotation marks is necessary or allowed.

Options:

-b: Display all values exactly in bytes rather than kB, MB, GB
    etc.
-B: Use binary units like KiB and MiB in the output, rather than
    decimal units like kB and MB (decimal units are the default).
-i: Honor already-installed packages. This means such packages
    will not be included in the shown download sizes. Use this
    option if you want to know what the installation of a group
    would download NOW for the local machine.
-c: Honor the download cache. Packages which are not installed,
    but have already been downloaded, are excluded from the shown
    download sizes. Specifying both options -i and -c give the
    best estimate of actual downloads required for installing a
    package group on the local machine in its current state.
-d: Include the download sizes of all mandatory installation
    dependencies in the group size calculation. Note that this
    will include *everything* down to the C library and X server
    if needed, and will therefore be *much* larger than the
    download sizes of the requested packages allone. It will also
    take *much* longer to calculate. However, this option allows
    one to determine how fat an application actually is, and what
    would need to be downloaded for a given package group on a
    minimalistic system where nothing (except for kernel and
    bootloader) has been installed yet.
-r: Include recommended packages by each package group in the
    download size. By default, recommended packages are not
    automatically included.
-s: Include suggested packages by each package group in the
    download size. By default, suggested packages are not
    automatically included.
-h: Display this help.
-V: Display version of $APPLICATION_NAME and exit.
EOF
}

include_all_dependencies=false
include_recommended=false
include_suggested=false
DEBUG=false
use_binary_units=false
units_are_bytes=false
honor_already_installed=false
honor_download_cache=false
while getopts ciBbDrsdhV opt
do
	case $opt in
		c) honor_download_cache=true;;
		i) honor_already_installed=true;;
		b) units_are_bytes=true;;
		B) use_binary_units=true;;
		D) DEBUG=true;;
		r) include_recommended=true;;
		s) include_suggested=true;;
		d) include_all_dependencies=true;;
		h) exit_help;;
		V) exit_version;;
		*) false || exit
	esac
done
shift `expr $OPTIND - 1 || :`

b2i() {
	$1 && echo 1 || echo 0
}

process_group() {
	printf '%s: ' "$*"
	# Build apt-get command line, starting from behind.
	set -- --print-uris -qq -- "$@"
	if $honor_download_cache
	then
		:
	else
		# Make apt-get think there are no downloaded files yet.
		set -- -o Dir::Cache::archives=/var/empty/ "$@"
	fi
	if $honor_already_installed
	then
		:
	elif $include_all_dependencies
	then
		# Make apt-get forget that many packages are already
		# installed.
		set -- -o Dir::State::status=/dev/null "$@"
	fi
	set -- -o APT::Install-Suggests=`b2i $include_suggested` "$@"
	set -- -o APT::Install-Recommends=`b2i $include_recommended` "$@"
	if $honor_already_installed
	then
		:
	else
		set -- --reinstall "$@"
	fi
	set -- --download "$@"
	set apt-get install "$@"
	if $DEBUG
	then
		local line arg
		line=
		for arg
		do
			case $arg in
				*" "*) arg="'$arg'"
			esac
			line=$line${line:+ }$arg
		done
		echo "$line" >& 2
		return
	fi
	"$@" | {
		s=0
		while IFS= read line
		do
			eval 'set -- $line'
			s=`expr $s + $3`
		done
		echo $s
	}
}

t='Package group download sizes, sorted by group totals'
echo "$t"; printf '%*s' ${#t} '' | tr -c = =; echo; echo
if $include_recommended
then
	cat << EOF # Line width 66
* The download sizes of all recommended packages are included for
  each package group.

EOF
fi
if $include_suggested
then
	cat << EOF # Line width 66
* The download sizes of all suggested packages are included for
  each package group.

EOF
fi
if $include_all_dependencies
then
	cat << EOF # Line width 66
* The download sizes of all packages directly or indirectly
  required by the resulting list of packages are also included
  for each package group.

EOF
fi
if $honor_already_installed
then
	cat << EOF # Line width 66
* Packages which are already installed on the local machine are
  excluded from the displayed download sizes.

EOF
fi
if $honor_download_cache
then
	cat << EOF # Line width 66
* Packages for which the installation files have already been
  downloaded to the local download cache are excluded from the
  displayed download sizes. It does not matter whether they are
  actually installed or not.

EOF
fi
decimal_point=
eval `locale -k LC_NUMERIC | grep ^decimal_point=` 2> /dev/null || :
: ${decimal_point:="."}
if test $# = 0
then
	while IFS= read -r line
	do
		process_group $line
	done
else
	for line
	do
		process_group $line
	done
fi | sort -t : -nk2 | while IFS= read -r line
do
	bytes=`expr x"$line" : x'.*\(: [0-9]\{1,\}\)$'`
	bytes=${bytes#": "}; line=${line%"$bytes"}
	divisor=`$use_binary_units && echo 1024 || echo 1000`
	limit=$divisor
	for unit in bytes K M G T P E Z Y
	do
		if test $unit != bytes
		then
			case $unit=$use_binary_units in
				K=false) unit=k
			esac
			$use_binary_units && unit=${unit}i
			unit=${unit}B
		fi
		if
			$units_are_bytes || test $unit = Y \
			|| test $bytes -lt $limit
		then
			if test $unit != bytes
			then
				leading=${bytes%?}
				fractional=${bytes#$leading}
				bytes=$leading$decimal_point$fractional
			fi
			bytes="$bytes $unit"
			break
		fi
		if test $unit = bytes
		then
			limit=`expr $divisor \* 10`
			bytes=`expr $bytes \* 10 || :`
			divisor2=`expr $divisor \* 2`
		fi
		# bytes = floor(bytes / divisor + 0.5)
		bytes=`expr \( $bytes \* 2 + $divisor \) / $divisor2 || :`
	done
	printf '%s\n' "$line$bytes"
done
